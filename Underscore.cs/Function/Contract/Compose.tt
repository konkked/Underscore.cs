<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using System;

// This code has been automatically generated
// if you want to make changes make them on 
// the corresponding the text template file
// Compose.tt
namespace Underscore.Function
{

	public interface IComposeComponent
	{

<#

    const string argNames = "abcdefghijklmnopqrstuvwxyz";
    const string resultTypeArg = "TResult";
    var methodName = "Apply";


    for (int i = 1; i < 17; i++)
    {
		var typeArgs = Enumerable.Range(1, i).Select(_ => "T").Concat(new[]{"TResult"}).ToArray();
        var currTypeArgs = typeArgs.Take(i).Concat(new[] {resultTypeArg}).ToArray();
        var currTypeArgsString ="T, TResult";
        var fnSig = string.Format("Func<{0}>", string.Join(", ",typeArgs));
        var retSig = "TResult";

        var currSigArgs = string.Format("{0} function , T[] arguments ",fnSig);
		
		#>
		
        /// <summary>
        /// Calls a function using the passed array of arguments
        /// </summary>
		<#=retSig#> <#=methodName#><<#=currTypeArgsString#>>( <#=currSigArgs#> );
		
		<#
	}

    methodName = "Call";
	for (int i = 1; i < 17; i++)
	{
	    var typeArgs = Enumerable.Range(1, i).Select(j => "T" + j);
		var memberArgs = typeArgs.Zip(argNames, (l, r) => l + " " + r);
        
		typeArgs = typeArgs.Concat(new[]{"TResult"}).ToArray();
        var currTypeArgs = typeArgs.Take(i).Concat(new[] {resultTypeArg}).ToArray();
	    var currTypeArgsString = string.Join(", ", currTypeArgs);
        var fnSig = string.Format("Func<{0}>", string.Join(", ",typeArgs));
	    var argSig = string.Join(" ,", new[] {fnSig+" function"}.Concat(memberArgs));
        var retSig = "TResult";

		
		#>
		
        /// <summary>
        /// Calls the function passed with the given arguments as the parameters 
        /// </summary>
		<#=retSig#> <#=methodName#><<#=currTypeArgsString#>>( <#=argSig#> );
		
		<#
	}

	methodName = "Compose";
    var startType = "TStart";
    var endType = "TResult";
    var startVarName = "start";
    var endVarName = "end";
    var retvSig = "Func<TStart,TResult>";
	for (int i = 0; i < 16; i++)
	{
	    string[] typeArgs;
	    string[] currArgNames;

	    string[] memberArgs;
		
		if (i == 0)
		{
		    typeArgs = new[] {startType,"TMid", endType};
		    currArgNames = new[] {startVarName, endVarName};
		}
	    else if (i == 1)
	    {
	        typeArgs = new[] {startType, "TLink1","TLink2", endType};
	        currArgNames = new[] {startVarName, "mid", endVarName};
	    }
	    else
	    {
	        typeArgs =
	            new[] {startType}.Concat(Enumerable.Range(1, i+1).Select(j => "TLink" + j))
	                .Concat(new[] {endType})
	                .ToArray();
	        currArgNames =
	            new[] {startVarName}.Concat(Enumerable.Range(0, i).Select(j => argNames[j].ToString()))
	                .Concat(new[] {endVarName})
	                .ToArray();
	    }
	    var currArgsTypes =
	            Enumerable.Range(1, typeArgs.Length - 1)
	                .Select(j => string.Format("Func<{0},{1}>", typeArgs[j - 1], typeArgs[j]));
	        memberArgs = currArgNames.Zip(currArgsTypes, (l, r) =>r+" "+l).ToArray();

	        var methodSig = string.Format("{0} {1}<{2}>({3});", retvSig, methodName, string.Join(", ", typeArgs),
	            string.Join(", ", memberArgs));

		
		#>
		
        /// <summary>
        /// Calls the function passed with the given arguments as the parameters 
        /// </summary>
		<#=methodSig#>
		
		<#
	}
#>
	    /// <summary>
        /// Creates a composition of function taking the same result and input parameter
        /// </summary>
        Func<T, T> Compose<T>( params Func<T, T>[ ] functions );

	}

}